{"ast":null,"code":"var Util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar Packets = require('../packets');\nvar ErrorConstants = require('../constants/errors');\nvar Timer = require('../Timer');\n\n// istanbul ignore next: Node.js < 0.10 not covered\nvar listenerCount = EventEmitter.listenerCount || function (emitter, type) {\n  return emitter.listeners(type).length;\n};\nvar LONG_STACK_DELIMITER = '\\n    --------------------\\n';\nmodule.exports = Sequence;\nUtil.inherits(Sequence, EventEmitter);\nfunction Sequence(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  EventEmitter.call(this);\n  options = options || {};\n  this._callback = callback;\n  this._callSite = null;\n  this._ended = false;\n  this._timeout = options.timeout;\n  this._timer = new Timer(this);\n}\nSequence.determinePacket = function (byte) {\n  switch (byte) {\n    case 0x00:\n      return Packets.OkPacket;\n    case 0xfe:\n      return Packets.EofPacket;\n    case 0xff:\n      return Packets.ErrorPacket;\n    default:\n      return undefined;\n  }\n};\nSequence.prototype.hasErrorHandler = function () {\n  return Boolean(this._callback) || listenerCount(this, 'error') > 1;\n};\nSequence.prototype._packetToError = function (packet) {\n  var code = ErrorConstants[packet.errno] || 'UNKNOWN_CODE_PLEASE_REPORT';\n  var err = new Error(code + ': ' + packet.message);\n  err.code = code;\n  err.errno = packet.errno;\n  err.sqlMessage = packet.message;\n  err.sqlState = packet.sqlState;\n  return err;\n};\nSequence.prototype.end = function (err) {\n  if (this._ended) {\n    return;\n  }\n  this._ended = true;\n  if (err) {\n    this._addLongStackTrace(err);\n  }\n\n  // Without this we are leaking memory. This problem was introduced in\n  // 8189925374e7ce3819bbe88b64c7b15abac96b16. I suspect that the error object\n  // causes a cyclic reference that the GC does not detect properly, but I was\n  // unable to produce a standalone version of this leak. This would be a great\n  // challenge for somebody interested in difficult problems : )!\n  this._callSite = null;\n\n  // try...finally for exception safety\n  try {\n    if (err) {\n      this.emit('error', err);\n    }\n  } finally {\n    try {\n      if (this._callback) {\n        this._callback.apply(this, arguments);\n      }\n    } finally {\n      this.emit('end');\n    }\n  }\n};\nSequence.prototype['OkPacket'] = function (packet) {\n  this.end(null, packet);\n};\nSequence.prototype['ErrorPacket'] = function (packet) {\n  this.end(this._packetToError(packet));\n};\n\n// Implemented by child classes\nSequence.prototype.start = function () {};\nSequence.prototype._addLongStackTrace = function _addLongStackTrace(err) {\n  var callSiteStack = this._callSite && this._callSite.stack;\n  if (!callSiteStack || typeof callSiteStack !== 'string') {\n    // No recorded call site\n    return;\n  }\n  if (err.stack.indexOf(LONG_STACK_DELIMITER) !== -1) {\n    // Error stack already looks long\n    return;\n  }\n  var index = callSiteStack.indexOf('\\n');\n  if (index !== -1) {\n    // Append recorded call site\n    err.stack += LONG_STACK_DELIMITER + callSiteStack.substr(index + 1);\n  }\n};\nSequence.prototype._onTimeout = function _onTimeout() {\n  this.emit('timeout');\n};","map":null,"metadata":{},"sourceType":"script"}