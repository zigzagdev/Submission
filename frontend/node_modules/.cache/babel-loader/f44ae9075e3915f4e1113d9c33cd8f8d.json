{"ast":null,"code":"var Parser = require('./Parser');\nvar Sequences = require('./sequences');\nvar Packets = require('./packets');\nvar Stream = require('stream').Stream;\nvar Util = require('util');\nvar PacketWriter = require('./PacketWriter');\nmodule.exports = Protocol;\nUtil.inherits(Protocol, Stream);\nfunction Protocol(options) {\n  Stream.call(this);\n  options = options || {};\n  this.readable = true;\n  this.writable = true;\n  this._config = options.config || {};\n  this._connection = options.connection;\n  this._callback = null;\n  this._fatalError = null;\n  this._quitSequence = null;\n  this._handshake = false;\n  this._handshaked = false;\n  this._ended = false;\n  this._destroyed = false;\n  this._queue = [];\n  this._handshakeInitializationPacket = null;\n  this._parser = new Parser({\n    onError: this.handleParserError.bind(this),\n    onPacket: this._parsePacket.bind(this),\n    config: this._config\n  });\n}\nProtocol.prototype.write = function (buffer) {\n  this._parser.write(buffer);\n  return true;\n};\nProtocol.prototype.handshake = function handshake(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options.config = this._config;\n  var sequence = this._enqueue(new Sequences.Handshake(options, callback));\n  this._handshake = true;\n  return sequence;\n};\nProtocol.prototype.query = function query(options, callback) {\n  return this._enqueue(new Sequences.Query(options, callback));\n};\nProtocol.prototype.changeUser = function changeUser(options, callback) {\n  return this._enqueue(new Sequences.ChangeUser(options, callback));\n};\nProtocol.prototype.ping = function ping(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._enqueue(new Sequences.Ping(options, callback));\n};\nProtocol.prototype.stats = function stats(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  return this._enqueue(new Sequences.Statistics(options, callback));\n};\nProtocol.prototype.quit = function quit(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var self = this;\n  var sequence = this._enqueue(new Sequences.Quit(options, callback));\n  sequence.on('end', function () {\n    self.end();\n  });\n  return this._quitSequence = sequence;\n};\nProtocol.prototype.end = function () {\n  if (this._ended) {\n    return;\n  }\n  this._ended = true;\n  if (this._quitSequence && (this._quitSequence._ended || this._queue[0] === this._quitSequence)) {\n    this._quitSequence.end();\n    this.emit('end');\n    return;\n  }\n  var err = new Error('Connection lost: The server closed the connection.');\n  err.fatal = true;\n  err.code = 'PROTOCOL_CONNECTION_LOST';\n  this._delegateError(err);\n};\nProtocol.prototype.pause = function () {\n  this._parser.pause();\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n  var seq = this._queue[0];\n  if (seq && seq.emit) {\n    seq.emit('pause');\n  }\n};\nProtocol.prototype.resume = function () {\n  this._parser.resume();\n  // Since there is a file stream in query, we must transmit pause/resume event to current sequence.\n  var seq = this._queue[0];\n  if (seq && seq.emit) {\n    seq.emit('resume');\n  }\n};\nProtocol.prototype._enqueue = function (sequence) {\n  if (!this._validateEnqueue(sequence)) {\n    return sequence;\n  }\n  if (this._config.trace) {\n    // Long stack trace support\n    sequence._callSite = sequence._callSite || new Error();\n  }\n  this._queue.push(sequence);\n  this.emit('enqueue', sequence);\n  var self = this;\n  sequence.on('error', function (err) {\n    self._delegateError(err, sequence);\n  }).on('packet', function (packet) {\n    sequence._timer.active();\n    self._emitPacket(packet);\n  }).on('timeout', function () {\n    var err = new Error(sequence.constructor.name + ' inactivity timeout');\n    err.code = 'PROTOCOL_SEQUENCE_TIMEOUT';\n    err.fatal = true;\n    err.timeout = sequence._timeout;\n    self._delegateError(err, sequence);\n  });\n  if (sequence.constructor === Sequences.Handshake) {\n    sequence.on('start-tls', function () {\n      sequence._timer.active();\n      self._connection._startTLS(function (err) {\n        if (err) {\n          // SSL negotiation error are fatal\n          err.code = 'HANDSHAKE_SSL_ERROR';\n          err.fatal = true;\n          sequence.end(err);\n          return;\n        }\n        sequence._timer.active();\n        sequence._tlsUpgradeCompleteHandler();\n      });\n    });\n    sequence.on('end', function () {\n      self._handshaked = true;\n      if (!self._fatalError) {\n        self.emit('handshake', self._handshakeInitializationPacket);\n      }\n    });\n  }\n  sequence.on('end', function () {\n    self._dequeue(sequence);\n  });\n  if (this._queue.length === 1) {\n    this._parser.resetPacketNumber();\n    this._startSequence(sequence);\n  }\n  return sequence;\n};\nProtocol.prototype._validateEnqueue = function _validateEnqueue(sequence) {\n  var err;\n  var prefix = 'Cannot enqueue ' + sequence.constructor.name;\n  if (this._fatalError) {\n    err = new Error(prefix + ' after fatal error.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_FATAL_ERROR';\n  } else if (this._quitSequence) {\n    err = new Error(prefix + ' after invoking quit.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_QUIT';\n  } else if (this._destroyed) {\n    err = new Error(prefix + ' after being destroyed.');\n    err.code = 'PROTOCOL_ENQUEUE_AFTER_DESTROY';\n  } else if ((this._handshake || this._handshaked) && sequence.constructor === Sequences.Handshake) {\n    err = new Error(prefix + ' after already enqueuing a Handshake.');\n    err.code = 'PROTOCOL_ENQUEUE_HANDSHAKE_TWICE';\n  } else {\n    return true;\n  }\n  var self = this;\n  err.fatal = false;\n\n  // add error handler\n  sequence.on('error', function (err) {\n    self._delegateError(err, sequence);\n  });\n  process.nextTick(function () {\n    sequence.end(err);\n  });\n  return false;\n};\nProtocol.prototype._parsePacket = function () {\n  var sequence = this._queue[0];\n  if (!sequence) {\n    var err = new Error('Received packet with no active sequence.');\n    err.code = 'PROTOCOL_STRAY_PACKET';\n    err.fatal = true;\n    this._delegateError(err);\n    return;\n  }\n  var Packet = this._determinePacket(sequence);\n  var packet = new Packet({\n    protocol41: this._config.protocol41\n  });\n  var packetName = Packet.name;\n\n  // Special case: Faster dispatch, and parsing done inside sequence\n  if (Packet === Packets.RowDataPacket) {\n    sequence.RowDataPacket(packet, this._parser, this._connection);\n    if (this._config.debug) {\n      this._debugPacket(true, packet);\n    }\n    return;\n  }\n  if (this._config.debug) {\n    this._parsePacketDebug(packet);\n  } else {\n    packet.parse(this._parser);\n  }\n  if (Packet === Packets.HandshakeInitializationPacket) {\n    this._handshakeInitializationPacket = packet;\n    this.emit('initialize', packet);\n  }\n  sequence._timer.active();\n  if (!sequence[packetName]) {\n    var err = new Error('Received packet in the wrong sequence.');\n    err.code = 'PROTOCOL_INCORRECT_PACKET_SEQUENCE';\n    err.fatal = true;\n    this._delegateError(err);\n    return;\n  }\n  sequence[packetName](packet);\n};\nProtocol.prototype._parsePacketDebug = function _parsePacketDebug(packet) {\n  try {\n    packet.parse(this._parser);\n  } finally {\n    this._debugPacket(true, packet);\n  }\n};\nProtocol.prototype._emitPacket = function (packet) {\n  var packetWriter = new PacketWriter();\n  packet.write(packetWriter);\n  this.emit('data', packetWriter.toBuffer(this._parser));\n  if (this._config.debug) {\n    this._debugPacket(false, packet);\n  }\n};\nProtocol.prototype._determinePacket = function (sequence) {\n  var firstByte = this._parser.peak();\n  if (sequence.determinePacket) {\n    var Packet = sequence.determinePacket(firstByte, this._parser);\n    if (Packet) {\n      return Packet;\n    }\n  }\n  switch (firstByte) {\n    case 0x00:\n      return Packets.OkPacket;\n    case 0xfe:\n      return Packets.EofPacket;\n    case 0xff:\n      return Packets.ErrorPacket;\n  }\n  throw new Error('Could not determine packet, firstByte = ' + firstByte);\n};\nProtocol.prototype._dequeue = function (sequence) {\n  sequence._timer.stop();\n\n  // No point in advancing the queue, we are dead\n  if (this._fatalError) {\n    return;\n  }\n  this._queue.shift();\n  var sequence = this._queue[0];\n  if (!sequence) {\n    this.emit('drain');\n    return;\n  }\n  this._parser.resetPacketNumber();\n  this._startSequence(sequence);\n};\nProtocol.prototype._startSequence = function (sequence) {\n  if (sequence._timeout > 0 && isFinite(sequence._timeout)) {\n    sequence._timer.start(sequence._timeout);\n  }\n  if (sequence.constructor === Sequences.ChangeUser) {\n    sequence.start(this._handshakeInitializationPacket);\n  } else {\n    sequence.start();\n  }\n};\nProtocol.prototype.handleNetworkError = function (err) {\n  err.fatal = true;\n  var sequence = this._queue[0];\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\nProtocol.prototype.handleParserError = function handleParserError(err) {\n  var sequence = this._queue[0];\n  if (sequence) {\n    sequence.end(err);\n  } else {\n    this._delegateError(err);\n  }\n};\nProtocol.prototype._delegateError = function (err, sequence) {\n  // Stop delegating errors after the first fatal error\n  if (this._fatalError) {\n    return;\n  }\n  if (err.fatal) {\n    this._fatalError = err;\n  }\n  if (this._shouldErrorBubbleUp(err, sequence)) {\n    // Can't use regular 'error' event here as that always destroys the pipe\n    // between socket and protocol which is not what we want (unless the\n    // exception was fatal).\n    this.emit('unhandledError', err);\n  } else if (err.fatal) {\n    // Send fatal error to all sequences in the queue\n    var queue = this._queue;\n    process.nextTick(function () {\n      queue.forEach(function (sequence) {\n        sequence.end(err);\n      });\n      queue.length = 0;\n    });\n  }\n\n  // Make sure the stream we are piping to is getting closed\n  if (err.fatal) {\n    this.emit('end', err);\n  }\n};\nProtocol.prototype._shouldErrorBubbleUp = function (err, sequence) {\n  if (sequence) {\n    if (sequence.hasErrorHandler()) {\n      return false;\n    } else if (!err.fatal) {\n      return true;\n    }\n  }\n  return err.fatal && !this._hasPendingErrorHandlers();\n};\nProtocol.prototype._hasPendingErrorHandlers = function () {\n  return this._queue.some(function (sequence) {\n    return sequence.hasErrorHandler();\n  });\n};\nProtocol.prototype.destroy = function () {\n  this._destroyed = true;\n  this._parser.pause();\n  if (this._connection.state !== 'disconnected') {\n    if (!this._ended) {\n      this.end();\n    }\n  }\n};\nProtocol.prototype._debugPacket = function (incoming, packet) {\n  var connection = this._connection;\n  var direction = incoming ? '<--' : '-->';\n  var packetName = packet.constructor.name;\n  var threadId = connection && connection.threadId !== null ? ' (' + connection.threadId + ')' : '';\n\n  // check for debug packet restriction\n  if (Array.isArray(this._config.debug) && this._config.debug.indexOf(packetName) === -1) {\n    return;\n  }\n  var packetPayload = Util.inspect(packet).replace(/^[^{]+/, '');\n  console.log('%s%s %s %s\\n', direction, threadId, packetName, packetPayload);\n};","map":null,"metadata":{},"sourceType":"script"}