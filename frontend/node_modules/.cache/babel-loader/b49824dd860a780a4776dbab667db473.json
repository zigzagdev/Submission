{"ast":null,"code":"var Crypto = require('crypto');\nvar Events = require('events');\nvar Net = require('net');\nvar tls = require('tls');\nvar ConnectionConfig = require('./ConnectionConfig');\nvar Protocol = require('./protocol/Protocol');\nvar SqlString = require('./protocol/SqlString');\nvar Query = require('./protocol/sequences/Query');\nvar Util = require('util');\nmodule.exports = Connection;\nUtil.inherits(Connection, Events.EventEmitter);\nfunction Connection(options) {\n  Events.EventEmitter.call(this);\n  this.config = options.config;\n  this._socket = options.socket;\n  this._protocol = new Protocol({\n    config: this.config,\n    connection: this\n  });\n  this._connectCalled = false;\n  this.state = 'disconnected';\n  this.threadId = null;\n}\nConnection.createQuery = function createQuery(sql, values, callback) {\n  if (sql instanceof Query) {\n    return sql;\n  }\n  var cb = callback;\n  var options = {};\n  if (typeof sql === 'function') {\n    cb = sql;\n  } else if (typeof sql === 'object') {\n    options = Object.create(sql);\n    if (typeof values === 'function') {\n      cb = values;\n    } else if (values !== undefined) {\n      Object.defineProperty(options, 'values', {\n        value: values\n      });\n    }\n  } else {\n    options.sql = sql;\n    if (typeof values === 'function') {\n      cb = values;\n    } else if (values !== undefined) {\n      options.values = values;\n    }\n  }\n  if (cb !== undefined) {\n    cb = wrapCallbackInDomain(null, cb);\n    if (cb === undefined) {\n      throw new TypeError('argument callback must be a function when provided');\n    }\n  }\n  return new Query(options, cb);\n};\nConnection.prototype.connect = function connect(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (!this._connectCalled) {\n    this._connectCalled = true;\n\n    // Connect either via a UNIX domain socket or a TCP socket.\n    this._socket = this.config.socketPath ? Net.createConnection(this.config.socketPath) : Net.createConnection(this.config.port, this.config.host);\n\n    // Connect socket to connection domain\n    if (Events.usingDomains) {\n      this._socket.domain = this.domain;\n    }\n    var connection = this;\n    this._protocol.on('data', function (data) {\n      connection._socket.write(data);\n    });\n    this._socket.on('data', wrapToDomain(connection, function (data) {\n      connection._protocol.write(data);\n    }));\n    this._protocol.on('end', function () {\n      connection._socket.end();\n    });\n    this._socket.on('end', wrapToDomain(connection, function () {\n      connection._protocol.end();\n    }));\n    this._socket.on('error', this._handleNetworkError.bind(this));\n    this._socket.on('connect', this._handleProtocolConnect.bind(this));\n    this._protocol.on('handshake', this._handleProtocolHandshake.bind(this));\n    this._protocol.on('initialize', this._handleProtocolInitialize.bind(this));\n    this._protocol.on('unhandledError', this._handleProtocolError.bind(this));\n    this._protocol.on('drain', this._handleProtocolDrain.bind(this));\n    this._protocol.on('end', this._handleProtocolEnd.bind(this));\n    this._protocol.on('enqueue', this._handleProtocolEnqueue.bind(this));\n    if (this.config.connectTimeout) {\n      var handleConnectTimeout = this._handleConnectTimeout.bind(this);\n      this._socket.setTimeout(this.config.connectTimeout, handleConnectTimeout);\n      this._socket.once('connect', function () {\n        this.setTimeout(0, handleConnectTimeout);\n      });\n    }\n  }\n  this._protocol.handshake(options, wrapCallbackInDomain(this, callback));\n};\nConnection.prototype.changeUser = function changeUser(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  this._implyConnect();\n  var charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : this.config.charsetNumber;\n  return this._protocol.changeUser({\n    user: options.user || this.config.user,\n    password: options.password || this.config.password,\n    database: options.database || this.config.database,\n    timeout: options.timeout,\n    charsetNumber: charsetNumber,\n    currentConfig: this.config\n  }, wrapCallbackInDomain(this, callback));\n};\nConnection.prototype.beginTransaction = function beginTransaction(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options.sql = 'START TRANSACTION';\n  options.values = null;\n  return this.query(options, callback);\n};\nConnection.prototype.commit = function commit(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options.sql = 'COMMIT';\n  options.values = null;\n  return this.query(options, callback);\n};\nConnection.prototype.rollback = function rollback(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options.sql = 'ROLLBACK';\n  options.values = null;\n  return this.query(options, callback);\n};\nConnection.prototype.query = function query(sql, values, cb) {\n  var query = Connection.createQuery(sql, values, cb);\n  query._connection = this;\n  if (!(typeof sql === 'object' && 'typeCast' in sql)) {\n    query.typeCast = this.config.typeCast;\n  }\n  if (query.sql) {\n    query.sql = this.format(query.sql, query.values);\n  }\n  if (query._callback) {\n    query._callback = wrapCallbackInDomain(this, query._callback);\n  }\n  this._implyConnect();\n  return this._protocol._enqueue(query);\n};\nConnection.prototype.ping = function ping(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  this._implyConnect();\n  this._protocol.ping(options, wrapCallbackInDomain(this, callback));\n};\nConnection.prototype.statistics = function statistics(options, callback) {\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  this._implyConnect();\n  this._protocol.stats(options, wrapCallbackInDomain(this, callback));\n};\nConnection.prototype.end = function end(options, callback) {\n  var cb = callback;\n  var opts = options;\n  if (!callback && typeof options === 'function') {\n    cb = options;\n    opts = null;\n  }\n\n  // create custom options reference\n  opts = Object.create(opts || null);\n  if (opts.timeout === undefined) {\n    // default timeout of 30 seconds\n    opts.timeout = 30000;\n  }\n  this._implyConnect();\n  this._protocol.quit(opts, wrapCallbackInDomain(this, cb));\n};\nConnection.prototype.destroy = function () {\n  this.state = 'disconnected';\n  this._implyConnect();\n  this._socket.destroy();\n  this._protocol.destroy();\n};\nConnection.prototype.pause = function () {\n  this._socket.pause();\n  this._protocol.pause();\n};\nConnection.prototype.resume = function () {\n  this._socket.resume();\n  this._protocol.resume();\n};\nConnection.prototype.escape = function (value) {\n  return SqlString.escape(value, false, this.config.timezone);\n};\nConnection.prototype.escapeId = function escapeId(value) {\n  return SqlString.escapeId(value, false);\n};\nConnection.prototype.format = function (sql, values) {\n  if (typeof this.config.queryFormat === 'function') {\n    return this.config.queryFormat.call(this, sql, values, this.config.timezone);\n  }\n  return SqlString.format(sql, values, this.config.stringifyObjects, this.config.timezone);\n};\nif (tls.TLSSocket) {\n  // 0.11+ environment\n  Connection.prototype._startTLS = function _startTLS(onSecure) {\n    var connection = this;\n    createSecureContext(this.config, function (err, secureContext) {\n      if (err) {\n        onSecure(err);\n        return;\n      }\n\n      // \"unpipe\"\n      connection._socket.removeAllListeners('data');\n      connection._protocol.removeAllListeners('data');\n\n      // socket <-> encrypted\n      var rejectUnauthorized = connection.config.ssl.rejectUnauthorized;\n      var secureEstablished = false;\n      var secureSocket = new tls.TLSSocket(connection._socket, {\n        rejectUnauthorized: rejectUnauthorized,\n        requestCert: true,\n        secureContext: secureContext,\n        isServer: false\n      });\n\n      // error handler for secure socket\n      secureSocket.on('_tlsError', function (err) {\n        if (secureEstablished) {\n          connection._handleNetworkError(err);\n        } else {\n          onSecure(err);\n        }\n      });\n\n      // cleartext <-> protocol\n      secureSocket.pipe(connection._protocol);\n      connection._protocol.on('data', function (data) {\n        secureSocket.write(data);\n      });\n      secureSocket.on('secure', function () {\n        secureEstablished = true;\n        onSecure(rejectUnauthorized ? this.ssl.verifyError() : null);\n      });\n\n      // start TLS communications\n      secureSocket._start();\n    });\n  };\n} else {\n  // pre-0.11 environment\n  Connection.prototype._startTLS = function _startTLS(onSecure) {\n    // before TLS:\n    //  _socket <-> _protocol\n    // after:\n    //  _socket <-> securePair.encrypted <-> securePair.cleartext <-> _protocol\n\n    var connection = this;\n    var credentials = Crypto.createCredentials({\n      ca: this.config.ssl.ca,\n      cert: this.config.ssl.cert,\n      ciphers: this.config.ssl.ciphers,\n      key: this.config.ssl.key,\n      passphrase: this.config.ssl.passphrase\n    });\n    var rejectUnauthorized = this.config.ssl.rejectUnauthorized;\n    var secureEstablished = false;\n    var securePair = tls.createSecurePair(credentials, false, true, rejectUnauthorized);\n\n    // error handler for secure pair\n    securePair.on('error', function (err) {\n      if (secureEstablished) {\n        connection._handleNetworkError(err);\n      } else {\n        onSecure(err);\n      }\n    });\n\n    // \"unpipe\"\n    this._socket.removeAllListeners('data');\n    this._protocol.removeAllListeners('data');\n\n    // socket <-> encrypted\n    securePair.encrypted.pipe(this._socket);\n    this._socket.on('data', function (data) {\n      securePair.encrypted.write(data);\n    });\n\n    // cleartext <-> protocol\n    securePair.cleartext.pipe(this._protocol);\n    this._protocol.on('data', function (data) {\n      securePair.cleartext.write(data);\n    });\n\n    // secure established\n    securePair.on('secure', function () {\n      secureEstablished = true;\n      if (!rejectUnauthorized) {\n        onSecure();\n        return;\n      }\n      var verifyError = this.ssl.verifyError();\n      var err = verifyError;\n\n      // node.js 0.6 support\n      if (typeof err === 'string') {\n        err = new Error(verifyError);\n        err.code = verifyError;\n      }\n      onSecure(err);\n    });\n\n    // node.js 0.8 bug\n    securePair._cycle = securePair.cycle;\n    securePair.cycle = function cycle() {\n      if (this.ssl && this.ssl.error) {\n        this.error();\n      }\n      return this._cycle.apply(this, arguments);\n    };\n  };\n}\nConnection.prototype._handleConnectTimeout = function () {\n  if (this._socket) {\n    this._socket.setTimeout(0);\n    this._socket.destroy();\n  }\n  var err = new Error('connect ETIMEDOUT');\n  err.errorno = 'ETIMEDOUT';\n  err.code = 'ETIMEDOUT';\n  err.syscall = 'connect';\n  this._handleNetworkError(err);\n};\nConnection.prototype._handleNetworkError = function (err) {\n  this._protocol.handleNetworkError(err);\n};\nConnection.prototype._handleProtocolError = function (err) {\n  this.state = 'protocol_error';\n  this.emit('error', err);\n};\nConnection.prototype._handleProtocolDrain = function () {\n  this.emit('drain');\n};\nConnection.prototype._handleProtocolConnect = function () {\n  this.state = 'connected';\n  this.emit('connect');\n};\nConnection.prototype._handleProtocolHandshake = function _handleProtocolHandshake() {\n  this.state = 'authenticated';\n};\nConnection.prototype._handleProtocolInitialize = function _handleProtocolInitialize(packet) {\n  this.threadId = packet.threadId;\n};\nConnection.prototype._handleProtocolEnd = function (err) {\n  this.state = 'disconnected';\n  this.emit('end', err);\n};\nConnection.prototype._handleProtocolEnqueue = function _handleProtocolEnqueue(sequence) {\n  this.emit('enqueue', sequence);\n};\nConnection.prototype._implyConnect = function () {\n  if (!this._connectCalled) {\n    this.connect();\n  }\n};\nfunction createSecureContext(config, cb) {\n  var context = null;\n  var error = null;\n  try {\n    context = tls.createSecureContext({\n      ca: config.ssl.ca,\n      cert: config.ssl.cert,\n      ciphers: config.ssl.ciphers,\n      key: config.ssl.key,\n      passphrase: config.ssl.passphrase\n    });\n  } catch (err) {\n    error = err;\n  }\n  cb(error, context);\n}\nfunction unwrapFromDomain(fn) {\n  return function () {\n    var domains = [];\n    var ret;\n    while (process.domain) {\n      domains.shift(process.domain);\n      process.domain.exit();\n    }\n    try {\n      ret = fn.apply(this, arguments);\n    } finally {\n      for (var i = 0; i < domains.length; i++) {\n        domains[i].enter();\n      }\n    }\n    return ret;\n  };\n}\nfunction wrapCallbackInDomain(ee, fn) {\n  if (typeof fn !== 'function') {\n    return undefined;\n  }\n  if (fn.domain) {\n    return fn;\n  }\n  var domain = process.domain;\n  if (domain) {\n    return domain.bind(fn);\n  } else if (ee) {\n    return unwrapFromDomain(wrapToDomain(ee, fn));\n  } else {\n    return fn;\n  }\n}\nfunction wrapToDomain(ee, fn) {\n  return function () {\n    if (Events.usingDomains && ee.domain) {\n      ee.domain.enter();\n      fn.apply(this, arguments);\n      ee.domain.exit();\n    } else {\n      fn.apply(this, arguments);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}