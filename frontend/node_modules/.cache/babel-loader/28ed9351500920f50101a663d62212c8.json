{"ast":null,"code":"var BIT_16 = Math.pow(2, 16);\nvar BIT_24 = Math.pow(2, 24);\nvar BUFFER_ALLOC_SIZE = Math.pow(2, 8);\n// The maximum precision JS Numbers can hold precisely\n// Don't panic: Good enough to represent byte values up to 8192 TB\nvar IEEE_754_BINARY_64_PRECISION = Math.pow(2, 53);\nvar MAX_PACKET_LENGTH = Math.pow(2, 24) - 1;\nvar Buffer = require('safe-buffer').Buffer;\nmodule.exports = PacketWriter;\nfunction PacketWriter() {\n  this._buffer = null;\n  this._offset = 0;\n}\nPacketWriter.prototype.toBuffer = function toBuffer(parser) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(0);\n    this._offset = 0;\n  }\n  var buffer = this._buffer;\n  var length = this._offset;\n  var packets = Math.floor(length / MAX_PACKET_LENGTH) + 1;\n  this._buffer = Buffer.allocUnsafe(length + packets * 4);\n  this._offset = 0;\n  for (var packet = 0; packet < packets; packet++) {\n    var isLast = packet + 1 === packets;\n    var packetLength = isLast ? length % MAX_PACKET_LENGTH : MAX_PACKET_LENGTH;\n    var packetNumber = parser.incrementPacketNumber();\n    this.writeUnsignedNumber(3, packetLength);\n    this.writeUnsignedNumber(1, packetNumber);\n    var start = packet * MAX_PACKET_LENGTH;\n    var end = start + packetLength;\n    this.writeBuffer(buffer.slice(start, end));\n  }\n  return this._buffer;\n};\nPacketWriter.prototype.writeUnsignedNumber = function (bytes, value) {\n  this._allocate(bytes);\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = value >> i * 8 & 0xff;\n  }\n};\nPacketWriter.prototype.writeFiller = function (bytes) {\n  this._allocate(bytes);\n  for (var i = 0; i < bytes; i++) {\n    this._buffer[this._offset++] = 0x00;\n  }\n};\nPacketWriter.prototype.writeNullTerminatedString = function (value, encoding) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n  var bytes = Buffer.byteLength(value, encoding || 'utf-8') + 1;\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, encoding);\n  this._buffer[this._offset + bytes - 1] = 0x00;\n  this._offset += bytes;\n};\nPacketWriter.prototype.writeString = function (value) {\n  // Typecast undefined into '' and numbers into strings\n  value = value || '';\n  value = value + '';\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, 'utf-8');\n  this._offset += bytes;\n};\nPacketWriter.prototype.writeBuffer = function (value) {\n  var bytes = value.length;\n  this._allocate(bytes);\n  value.copy(this._buffer, this._offset);\n  this._offset += bytes;\n};\nPacketWriter.prototype.writeLengthCodedNumber = function (value) {\n  if (value === null) {\n    this._allocate(1);\n    this._buffer[this._offset++] = 251;\n    return;\n  }\n  if (value <= 250) {\n    this._allocate(1);\n    this._buffer[this._offset++] = value;\n    return;\n  }\n  if (value > IEEE_754_BINARY_64_PRECISION) {\n    throw new Error('writeLengthCodedNumber: JS precision range exceeded, your ' + 'number is > 53 bit: \"' + value + '\"');\n  }\n  if (value < BIT_16) {\n    this._allocate(3);\n    this._buffer[this._offset++] = 252;\n  } else if (value < BIT_24) {\n    this._allocate(4);\n    this._buffer[this._offset++] = 253;\n  } else {\n    this._allocate(9);\n    this._buffer[this._offset++] = 254;\n  }\n\n  // 16 Bit\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = value >> 8 & 0xff;\n  if (value < BIT_16) {\n    return;\n  }\n\n  // 24 Bit\n  this._buffer[this._offset++] = value >> 16 & 0xff;\n  if (value < BIT_24) {\n    return;\n  }\n  this._buffer[this._offset++] = value >> 24 & 0xff;\n\n  // Hack: Get the most significant 32 bit (JS bitwise operators are 32 bit)\n  value = value.toString(2);\n  value = value.substr(0, value.length - 32);\n  value = parseInt(value, 2);\n  this._buffer[this._offset++] = value & 0xff;\n  this._buffer[this._offset++] = value >> 8 & 0xff;\n  this._buffer[this._offset++] = value >> 16 & 0xff;\n\n  // Set last byte to 0, as we can only support 53 bits in JS (see above)\n  this._buffer[this._offset++] = 0;\n};\nPacketWriter.prototype.writeLengthCodedBuffer = function (value) {\n  var bytes = value.length;\n  this.writeLengthCodedNumber(bytes);\n  this.writeBuffer(value);\n};\nPacketWriter.prototype.writeNullTerminatedBuffer = function (value) {\n  this.writeBuffer(value);\n  this.writeFiller(1); // 0x00 terminator\n};\n\nPacketWriter.prototype.writeLengthCodedString = function (value) {\n  if (value === null) {\n    this.writeLengthCodedNumber(null);\n    return;\n  }\n  value = value === undefined ? '' : String(value);\n  var bytes = Buffer.byteLength(value, 'utf-8');\n  this.writeLengthCodedNumber(bytes);\n  if (!bytes) {\n    return;\n  }\n  this._allocate(bytes);\n  this._buffer.write(value, this._offset, 'utf-8');\n  this._offset += bytes;\n};\nPacketWriter.prototype._allocate = function _allocate(bytes) {\n  if (!this._buffer) {\n    this._buffer = Buffer.alloc(Math.max(BUFFER_ALLOC_SIZE, bytes));\n    this._offset = 0;\n    return;\n  }\n  var bytesRemaining = this._buffer.length - this._offset;\n  if (bytesRemaining >= bytes) {\n    return;\n  }\n  var newSize = this._buffer.length + Math.max(BUFFER_ALLOC_SIZE, bytes);\n  var oldBuffer = this._buffer;\n  this._buffer = Buffer.alloc(newSize);\n  oldBuffer.copy(this._buffer);\n};","map":null,"metadata":{},"sourceType":"script"}