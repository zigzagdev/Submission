{"ast":null,"code":"var urlParse = require('url').parse;\nvar ClientConstants = require('./protocol/constants/client');\nvar Charsets = require('./protocol/constants/charsets');\nvar SSLProfiles = null;\nmodule.exports = ConnectionConfig;\nfunction ConnectionConfig(options) {\n  if (typeof options === 'string') {\n    options = ConnectionConfig.parseUrl(options);\n  }\n  this.host = options.host || 'localhost';\n  this.port = options.port || 3306;\n  this.localAddress = options.localAddress;\n  this.socketPath = options.socketPath;\n  this.user = options.user || undefined;\n  this.password = options.password || undefined;\n  this.database = options.database;\n  this.connectTimeout = options.connectTimeout === undefined ? 10 * 1000 : options.connectTimeout;\n  this.insecureAuth = options.insecureAuth || false;\n  this.supportBigNumbers = options.supportBigNumbers || false;\n  this.bigNumberStrings = options.bigNumberStrings || false;\n  this.dateStrings = options.dateStrings || false;\n  this.debug = options.debug;\n  this.trace = options.trace !== false;\n  this.stringifyObjects = options.stringifyObjects || false;\n  this.timezone = options.timezone || 'local';\n  this.flags = options.flags || '';\n  this.queryFormat = options.queryFormat;\n  this.pool = options.pool || undefined;\n  this.ssl = typeof options.ssl === 'string' ? ConnectionConfig.getSSLProfile(options.ssl) : options.ssl || false;\n  this.localInfile = options.localInfile === undefined ? true : options.localInfile;\n  this.multipleStatements = options.multipleStatements || false;\n  this.typeCast = options.typeCast === undefined ? true : options.typeCast;\n  if (this.timezone[0] === ' ') {\n    // \"+\" is a url encoded char for space so it\n    // gets translated to space when giving a\n    // connection string..\n    this.timezone = '+' + this.timezone.substr(1);\n  }\n  if (this.ssl) {\n    // Default rejectUnauthorized to true\n    this.ssl.rejectUnauthorized = this.ssl.rejectUnauthorized !== false;\n  }\n  this.maxPacketSize = 0;\n  this.charsetNumber = options.charset ? ConnectionConfig.getCharsetNumber(options.charset) : options.charsetNumber || Charsets.UTF8_GENERAL_CI;\n\n  // Set the client flags\n  var defaultFlags = ConnectionConfig.getDefaultFlags(options);\n  this.clientFlags = ConnectionConfig.mergeFlags(defaultFlags, options.flags);\n}\nConnectionConfig.mergeFlags = function mergeFlags(defaultFlags, userFlags) {\n  var allFlags = ConnectionConfig.parseFlagList(defaultFlags);\n  var newFlags = ConnectionConfig.parseFlagList(userFlags);\n\n  // Merge the new flags\n  for (var flag in newFlags) {\n    if (allFlags[flag] !== false) {\n      allFlags[flag] = newFlags[flag];\n    }\n  }\n\n  // Build flags\n  var flags = 0x0;\n  for (var flag in allFlags) {\n    if (allFlags[flag]) {\n      // TODO: Throw here on some future release\n      flags |= ClientConstants['CLIENT_' + flag] || 0x0;\n    }\n  }\n  return flags;\n};\nConnectionConfig.getCharsetNumber = function getCharsetNumber(charset) {\n  var num = Charsets[charset.toUpperCase()];\n  if (num === undefined) {\n    throw new TypeError('Unknown charset \\'' + charset + '\\'');\n  }\n  return num;\n};\nConnectionConfig.getDefaultFlags = function getDefaultFlags(options) {\n  var defaultFlags = ['-COMPRESS',\n  // Compression protocol *NOT* supported\n  '-CONNECT_ATTRS',\n  // Does *NOT* send connection attributes in Protocol::HandshakeResponse41\n  '+CONNECT_WITH_DB',\n  // One can specify db on connect in Handshake Response Packet\n  '+FOUND_ROWS',\n  // Send found rows instead of affected rows\n  '+IGNORE_SIGPIPE',\n  // Don't issue SIGPIPE if network failures\n  '+IGNORE_SPACE',\n  // Let the parser ignore spaces before '('\n  '+LOCAL_FILES',\n  // Can use LOAD DATA LOCAL\n  '+LONG_FLAG',\n  // Longer flags in Protocol::ColumnDefinition320\n  '+LONG_PASSWORD',\n  // Use the improved version of Old Password Authentication\n  '+MULTI_RESULTS',\n  // Can handle multiple resultsets for COM_QUERY\n  '+ODBC',\n  // Special handling of ODBC behaviour\n  '-PLUGIN_AUTH',\n  // Does *NOT* support auth plugins\n  '+PROTOCOL_41',\n  // Uses the 4.1 protocol\n  '+PS_MULTI_RESULTS',\n  // Can handle multiple resultsets for COM_STMT_EXECUTE\n  '+RESERVED',\n  // Unused\n  '+SECURE_CONNECTION',\n  // Supports Authentication::Native41\n  '+TRANSACTIONS' // Expects status flags\n  ];\n\n  if (options && options.localInfile !== undefined && !options.localInfile) {\n    // Disable LOCAL modifier for LOAD DATA INFILE\n    defaultFlags.push('-LOCAL_FILES');\n  }\n  if (options && options.multipleStatements) {\n    // May send multiple statements per COM_QUERY and COM_STMT_PREPARE\n    defaultFlags.push('+MULTI_STATEMENTS');\n  }\n  return defaultFlags;\n};\nConnectionConfig.getSSLProfile = function getSSLProfile(name) {\n  if (!SSLProfiles) {\n    SSLProfiles = require('./protocol/constants/ssl_profiles');\n  }\n  var ssl = SSLProfiles[name];\n  if (ssl === undefined) {\n    throw new TypeError('Unknown SSL profile \\'' + name + '\\'');\n  }\n  return ssl;\n};\nConnectionConfig.parseFlagList = function parseFlagList(flagList) {\n  var allFlags = Object.create(null);\n  if (!flagList) {\n    return allFlags;\n  }\n  var flags = !Array.isArray(flagList) ? String(flagList || '').toUpperCase().split(/\\s*,+\\s*/) : flagList;\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags[i];\n    var offset = 1;\n    var state = flag[0];\n    if (state === undefined) {\n      // TODO: throw here on some future release\n      continue;\n    }\n    if (state !== '-' && state !== '+') {\n      offset = 0;\n      state = '+';\n    }\n    allFlags[flag.substr(offset)] = state === '+';\n  }\n  return allFlags;\n};\nConnectionConfig.parseUrl = function (url) {\n  url = urlParse(url, true);\n  var options = {\n    host: url.hostname,\n    port: url.port,\n    database: url.pathname.substr(1)\n  };\n  if (url.auth) {\n    var auth = url.auth.split(':');\n    options.user = auth.shift();\n    options.password = auth.join(':');\n  }\n  if (url.query) {\n    for (var key in url.query) {\n      var value = url.query[key];\n      try {\n        // Try to parse this as a JSON expression first\n        options[key] = JSON.parse(value);\n      } catch (err) {\n        // Otherwise assume it is a plain string\n        options[key] = value;\n      }\n    }\n  }\n  return options;\n};","map":null,"metadata":{},"sourceType":"script"}